<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>多线程 | Gridea</title>
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico?v=1616415195787">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="http://localhost:4000/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="多线程 | Gridea - Atom Feed" href="http://localhost:4000/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="基本概念

进程（Process）、线程（Thread）、多线程

程序是指令和数据的集合，是一个静态的概念
进程是程序的一次的执行过程，是一个动态的概念。是系统资源分配的单位
通常在一个进程包含若干个线程，但至少有一个线程，如main。是..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://localhost:4000">
  <img class="avatar" src="http://localhost:4000/images/avatar.png?v=1616415195787" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    上善若水
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              多线程
            </h2>
            <div class="post-info">
              <span>
                2021-03-18
              </span>
              <span>
                6 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="基本概念">基本概念</h1>
<ul>
<li>进程（Process）、线程（Thread）、多线程
<ol>
<li>程序是指令和数据的集合，是一个静态的概念</li>
<li>进程是程序的一次的执行过程，是一个动态的概念。是系统资源分配的单位</li>
<li>通常在一个进程包含若干个线程，但至少有一个线程，如main。是CPU调度和执行的单位</li>
<li>很多多线程是模拟出来的，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。</li>
</ol>
</li>
<li>在一个进程中，如果开辟了多个线程，线程的运行由CPU安排调度，先后顺序是不能人为干预的</li>
<li>对同一份资源进行操作时，会存在资源抢夺问题，需要加入并发控制</li>
<li>线程会带来额外的开销，如CPU调度时间，并发控制开销</li>
<li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li>
</ul>
<h1 id="创建线程三种方式">创建线程三种方式</h1>
<ul>
<li>继承Thread类</li>
</ul>
<pre><code class="language-java">//创建线程方式一：继承Threa类
public class TestThread1 extends Thread {
    @Override
    public void run() {
        //重写run（）方法
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;我在看代码---&quot; + i);
        }
    }

    public static void main(String[] args) {
        //main方法主线程体
        TestThread1 testThread1 = new TestThread1();
        //调用start（）方法开启线程
        testThread1.start();
        for (int i = 0; i &lt; 1000; i++) {
            System.out.println(&quot;我在学多线程---&quot; + i);
        }
    }
}
</code></pre>
<p>注意：线程开启不一定立即执行，由CPU调度执行</p>
<ul>
<li>实现Runnable（）接口，</li>
</ul>
<pre><code class="language-java">//创建线程方式二：实现Runnable（）接口
public class TestThread2 implements Runnable{
    @Override
    public void run() {
        //重写run（）方法
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;我在看代码---&quot; + i);
        }
    }

    public static void main(String[] args) {
        //创建Runnable（）接口实现类
        TestThread2 testThread2 = new TestThread2();
        //创建线程对象，通过线程对象开启我们的线程，代理
        new Thread(testThread2).start();
        for (int i = 0; i &lt; 1000; i++) {
            System.out.println(&quot;我在学多线程---&quot; + i);
        }
    }
}
</code></pre>
<ul>
<li>实现callable（）接口</li>
</ul>
<h1 id="静态代理模式">静态代理模式</h1>
<ul>
<li>真实对象和代理对象都要实现同一个接口</li>
<li>代理对象要代理真实角色</li>
<li>好处
<ol>
<li>代理对象可以做很多真实对象做不了的事</li>
<li>真实对象专注做自己事</li>
</ol>
</li>
</ul>
<h1 id="lambda表达式">Lambda表达式</h1>
<ul>
<li>函数式接口
<ol>
<li>任何接口，如果只包含唯一一个抽象方法，那么他就是函数式接口</li>
<li>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象</li>
</ol>
</li>
<li>Runnable接口就是一个函数式接口</li>
<li>Lambda表达式实现</li>
</ul>
<pre><code class="language-java">public class LambdaTest {

    public static void main(String[] args) {
        //实现Lambda表达式
        ILove i = (x) -&gt; {
            System.out.println(&quot;I love you!&quot; + x);
        };
        i.print(20);
    }
}

//定义一个函数式接口
interface ILove {
    void print(int x);
}
</code></pre>
<h1 id="线程状态">线程状态</h1>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1616295260818.png" alt="" loading="lazy"></figure>
<ul>
<li>线程停止
<ol>
<li>建议线程正常停止--&gt;利用次数，不建议死循环</li>
<li>建议使用标志位--&gt;设置一个标志位</li>
<li>不要使用stop或destroy等过时或者JDK不建议使用的方法</li>
</ol>
</li>
</ul>
<pre><code class="language-java">public class TestStop implements Runnable {
    //1、设置一个标识位
    private boolean flag = true;

    @Override
    public void run() {
        int i = 0;
        //2、线程中使用该标识符
        while (flag) {
            System.out.println(&quot;run...Thread&quot; + i++);
        }
    }

    //3、设置一个公开的方法停止线程，转换标识位
    public void stop() {
        this.flag = false;
    }

    public static void main(String[] args) {
        TestStop testStop = new TestStop();
        new Thread(testStop).start();
        
        for (int i = 0; i &lt; 200; i++) {
            System.out.println(&quot;main&quot; + i);
            if (i == 150) {
                //调用stop（）方法停止线程
                testStop.stop();
                System.out.println(&quot;线程停止了&quot;);
            }
        }
    }
}
</code></pre>
<ul>
<li>
<p>线程休眠</p>
<ol>
<li>Thread.sleep(时间) 指定当前线程阻塞的毫秒数</li>
<li>sleep可以模拟网络延时、倒计时等</li>
<li>每个对象都有一个锁，sleep不会释放锁</li>
</ol>
</li>
<li>
<p>线程礼让</p>
<ol>
<li>Thread.yield（）</li>
<li>将线程从运行状态转为就绪状态</li>
<li>CPU重新重新调度，但不一定成功</li>
</ol>
</li>
<li>
<p>线程强制执行</p>
<ol>
<li>join合并线程，将此线程执行完毕后，在执行其他线程，其他线程阻塞</li>
<li>可以想象成插队</li>
</ol>
</li>
</ul>
<pre><code class="language-java">public class TestJoin implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i &lt; 1000; i++) {
            System.out.println(&quot;线程VIP来了&quot; + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        //启动我们的线程
        TestJoin testJoin = new TestJoin();
        Thread thread = new Thread(testJoin);
        thread.start();

        //主线程
        for (int i = 0; i &lt; 500; i++) {
            if (i == 200)
                //插队
                thread.join();
            System.out.println(&quot;main&quot; + i);
        }
    }
}
</code></pre>
<ul>
<li>守护线程</li>
</ul>
<ol>
<li>线程分为用户线程和守护线程</li>
<li>虚拟机必须确保用户线程执行完毕</li>
<li>虚拟机不用等待守护线程执行完毕</li>
</ol>
<pre><code class="language-java">public class UnsafeBuyTicket {
    public static void main(String[] args) {
        BuyTicket station = new BuyTicket();
        new Thread(station, &quot;邓憨憨&quot;).start();
        new Thread(station, &quot;夜十七&quot;).start();
        new Thread(station, &quot;黄卡丽&quot;).start();
    }
}

class BuyTicket implements Runnable {
    private int tickets = 10;
    boolean flag = true;//外部停止线程方法

    @Override
    public void run() {
        //买票
        while (flag) {
            try {
                buy();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    //synchronized 同步方法 锁的是this.tickets
    private synchronized void buy() throws InterruptedException {
        if (tickets &lt;= 0) {
            flag = false;
            return;
        }
        Thread.sleep(100);
        System.out.println(Thread.currentThread().getName() + &quot;拿到了票&quot; + tickets--);
    }
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">创建线程三种方式</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">静态代理模式</a></li>
<li><a href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">Lambda表达式</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81">线程状态</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://localhost:4000/post/xie-fa/">
              <h3 class="post-title">
                写法
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="http://localhost:4000/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>Gridea</title>
    <updated>2021-03-22T12:13:18.843Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <subtitle>上善若水</subtitle>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[多线程]]></title>
        <id>http://localhost:4000/post/duo-xian-cheng/</id>
        <link href="http://localhost:4000/post/duo-xian-cheng/">
        </link>
        <updated>2021-03-18T13:12:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1>
<ul>
<li>进程（Process）、线程（Thread）、多线程
<ol>
<li>程序是指令和数据的集合，是一个静态的概念</li>
<li>进程是程序的一次的执行过程，是一个动态的概念。是系统资源分配的单位</li>
<li>通常在一个进程包含若干个线程，但至少有一个线程，如main。是CPU调度和执行的单位</li>
<li>很多多线程是模拟出来的，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。</li>
</ol>
</li>
<li>在一个进程中，如果开辟了多个线程，线程的运行由CPU安排调度，先后顺序是不能人为干预的</li>
<li>对同一份资源进行操作时，会存在资源抢夺问题，需要加入并发控制</li>
<li>线程会带来额外的开销，如CPU调度时间，并发控制开销</li>
<li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li>
</ul>
<h1 id="创建线程三种方式">创建线程三种方式</h1>
<ul>
<li>继承Thread类</li>
</ul>
<pre><code class="language-java">//创建线程方式一：继承Threa类
public class TestThread1 extends Thread {
    @Override
    public void run() {
        //重写run（）方法
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;我在看代码---&quot; + i);
        }
    }

    public static void main(String[] args) {
        //main方法主线程体
        TestThread1 testThread1 = new TestThread1();
        //调用start（）方法开启线程
        testThread1.start();
        for (int i = 0; i &lt; 1000; i++) {
            System.out.println(&quot;我在学多线程---&quot; + i);
        }
    }
}
</code></pre>
<p>注意：线程开启不一定立即执行，由CPU调度执行</p>
<ul>
<li>实现Runnable（）接口，</li>
</ul>
<pre><code class="language-java">//创建线程方式二：实现Runnable（）接口
public class TestThread2 implements Runnable{
    @Override
    public void run() {
        //重写run（）方法
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;我在看代码---&quot; + i);
        }
    }

    public static void main(String[] args) {
        //创建Runnable（）接口实现类
        TestThread2 testThread2 = new TestThread2();
        //创建线程对象，通过线程对象开启我们的线程，代理
        new Thread(testThread2).start();
        for (int i = 0; i &lt; 1000; i++) {
            System.out.println(&quot;我在学多线程---&quot; + i);
        }
    }
}
</code></pre>
<ul>
<li>实现callable（）接口</li>
</ul>
<h1 id="静态代理模式">静态代理模式</h1>
<ul>
<li>真实对象和代理对象都要实现同一个接口</li>
<li>代理对象要代理真实角色</li>
<li>好处
<ol>
<li>代理对象可以做很多真实对象做不了的事</li>
<li>真实对象专注做自己事</li>
</ol>
</li>
</ul>
<h1 id="lambda表达式">Lambda表达式</h1>
<ul>
<li>函数式接口
<ol>
<li>任何接口，如果只包含唯一一个抽象方法，那么他就是函数式接口</li>
<li>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象</li>
</ol>
</li>
<li>Runnable接口就是一个函数式接口</li>
<li>Lambda表达式实现</li>
</ul>
<pre><code class="language-java">public class LambdaTest {

    public static void main(String[] args) {
        //实现Lambda表达式
        ILove i = (x) -&gt; {
            System.out.println(&quot;I love you!&quot; + x);
        };
        i.print(20);
    }
}

//定义一个函数式接口
interface ILove {
    void print(int x);
}
</code></pre>
<h1 id="线程状态">线程状态</h1>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1616295260818.png" alt="" loading="lazy"></figure>
<ul>
<li>线程停止
<ol>
<li>建议线程正常停止--&gt;利用次数，不建议死循环</li>
<li>建议使用标志位--&gt;设置一个标志位</li>
<li>不要使用stop或destroy等过时或者JDK不建议使用的方法</li>
</ol>
</li>
</ul>
<pre><code class="language-java">public class TestStop implements Runnable {
    //1、设置一个标识位
    private boolean flag = true;

    @Override
    public void run() {
        int i = 0;
        //2、线程中使用该标识符
        while (flag) {
            System.out.println(&quot;run...Thread&quot; + i++);
        }
    }

    //3、设置一个公开的方法停止线程，转换标识位
    public void stop() {
        this.flag = false;
    }

    public static void main(String[] args) {
        TestStop testStop = new TestStop();
        new Thread(testStop).start();
        
        for (int i = 0; i &lt; 200; i++) {
            System.out.println(&quot;main&quot; + i);
            if (i == 150) {
                //调用stop（）方法停止线程
                testStop.stop();
                System.out.println(&quot;线程停止了&quot;);
            }
        }
    }
}
</code></pre>
<ul>
<li>
<p>线程休眠</p>
<ol>
<li>Thread.sleep(时间) 指定当前线程阻塞的毫秒数</li>
<li>sleep可以模拟网络延时、倒计时等</li>
<li>每个对象都有一个锁，sleep不会释放锁</li>
</ol>
</li>
<li>
<p>线程礼让</p>
<ol>
<li>Thread.yield（）</li>
<li>将线程从运行状态转为就绪状态</li>
<li>CPU重新重新调度，但不一定成功</li>
</ol>
</li>
<li>
<p>线程强制执行</p>
<ol>
<li>join合并线程，将此线程执行完毕后，在执行其他线程，其他线程阻塞</li>
<li>可以想象成插队</li>
</ol>
</li>
</ul>
<pre><code class="language-java">public class TestJoin implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i &lt; 1000; i++) {
            System.out.println(&quot;线程VIP来了&quot; + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        //启动我们的线程
        TestJoin testJoin = new TestJoin();
        Thread thread = new Thread(testJoin);
        thread.start();

        //主线程
        for (int i = 0; i &lt; 500; i++) {
            if (i == 200)
                //插队
                thread.join();
            System.out.println(&quot;main&quot; + i);
        }
    }
}
</code></pre>
<ul>
<li>守护线程</li>
</ul>
<ol>
<li>线程分为用户线程和守护线程</li>
<li>虚拟机必须确保用户线程执行完毕</li>
<li>虚拟机不用等待守护线程执行完毕</li>
</ol>
<pre><code class="language-java">public class UnsafeBuyTicket {
    public static void main(String[] args) {
        BuyTicket station = new BuyTicket();
        new Thread(station, &quot;邓憨憨&quot;).start();
        new Thread(station, &quot;夜十七&quot;).start();
        new Thread(station, &quot;黄卡丽&quot;).start();
    }
}

class BuyTicket implements Runnable {
    private int tickets = 10;
    boolean flag = true;//外部停止线程方法

    @Override
    public void run() {
        //买票
        while (flag) {
            try {
                buy();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    //synchronized 同步方法 锁的是this.tickets
    private synchronized void buy() throws InterruptedException {
        if (tickets &lt;= 0) {
            flag = false;
            return;
        }
        Thread.sleep(100);
        System.out.println(Thread.currentThread().getName() + &quot;拿到了票&quot; + tickets--);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[写法]]></title>
        <id>http://localhost:4000/post/xie-fa/</id>
        <link href="http://localhost:4000/post/xie-fa/">
        </link>
        <updated>2021-03-18T11:17:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="学习javacsript">学习javacsript</h1>
<ul>
<li>学习java</li>
<li>学习数据库<br>
1 dawd</li>
</ul>
<ol>
<li>学习java</li>
<li>学习数据库</li>
</ol>
<blockquote>
<p>这是引用</p>
<blockquote>
<p>这是引用</p>
</blockquote>
</blockquote>
<pre><code class="language-javascript">  在此输入代码
</code></pre>
<p>这是一个链接<a href="https://null-go.github.io/">我的主页</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java继承]]></title>
        <id>http://localhost:4000/post/java-ji-cheng/</id>
        <link href="http://localhost:4000/post/java-ji-cheng/">
        </link>
        <updated>2021-03-12T02:58:22.000Z</updated>
        <content type="html"><![CDATA[<p>1、父类的private修饰的数据与和方法不被子类继承，构造方法也不被子类继承。<br>
2、子类不是父类的一个子集，子类通常比父类包含更多的信息和方法。<br>
3、父类和子类应该满足“是一种”关系（is-a），例：圆形是一种几何图形。但不是所有的“是一种”关系（is-a）都该用继承来建模，例：正方形是一种矩形。<br>
4、子类只允许有一个父类。<br>
5、子类的构造函数会默认将super（）作为第一条语句。<br>
6、如果父类只有有参函数，子类的构造函数要传入父类的参数。super（参数）<br>
7、私有方法和静态方法不能被覆盖，即方法重写。<br>
8、方法重写具有相同的签名（方法名和参数列表）和返回值类型。<br>
9、可以用@Override来标记方法重写。<br>
10、方法重载可以重载同一个类中的方法，也可以重载继承父类的方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>http://localhost:4000/post/hello-gridea/</id>
        <link href="http://localhost:4000/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://1489368019.github.io</id>
    <title>Gridea</title>
    <updated>2021-03-21T02:57:00.173Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://1489368019.github.io"/>
    <link rel="self" href="https://1489368019.github.io/atom.xml"/>
    <subtitle>上善若水</subtitle>
    <logo>https://1489368019.github.io/images/avatar.png</logo>
    <icon>https://1489368019.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[多线程]]></title>
        <id>https://1489368019.github.io/post/duo-xian-cheng/</id>
        <link href="https://1489368019.github.io/post/duo-xian-cheng/">
        </link>
        <updated>2021-03-18T13:12:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1>
<ul>
<li>进程（Process）、线程（Thread）、多线程
<ol>
<li>程序是指令和数据的集合，是一个静态的概念</li>
<li>进程是程序的一次的执行过程，是一个动态的概念。是系统资源分配的单位</li>
<li>通常在一个进程包含若干个线程，但至少有一个线程，如main。是CPU调度和执行的单位</li>
<li>很多多线程是模拟出来的，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。</li>
</ol>
</li>
<li>在一个进程中，如果开辟了多个线程，线程的运行由CPU安排调度，先后顺序是不能人为干预的</li>
<li>对同一份资源进行操作时，会存在资源抢夺问题，需要加入并发控制</li>
<li>线程会带来额外的开销，如CPU调度时间，并发控制开销</li>
<li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li>
</ul>
<h1 id="创建线程三种方式">创建线程三种方式</h1>
<ul>
<li>继承Thread类</li>
</ul>
<pre><code class="language-java">//创建线程方式一：继承Threa类
public class TestThread1 extends Thread {
    @Override
    public void run() {
        //重写run（）方法
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;我在看代码---&quot; + i);
        }
    }

    public static void main(String[] args) {
        //main方法主线程体
        TestThread1 testThread1 = new TestThread1();
        //调用start（）方法开启线程
        testThread1.start();
        for (int i = 0; i &lt; 1000; i++) {
            System.out.println(&quot;我在学多线程---&quot; + i);
        }
    }
}
</code></pre>
<p>注意：线程开启不一定立即执行，由CPU调度执行</p>
<ul>
<li>实现Runnable（）接口，</li>
</ul>
<pre><code class="language-java">//创建线程方式二：实现Runnable（）接口
public class TestThread2 implements Runnable{
    @Override
    public void run() {
        //重写run（）方法
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;我在看代码---&quot; + i);
        }
    }

    public static void main(String[] args) {
        //创建Runnable（）接口实现类
        TestThread2 testThread2 = new TestThread2();
        //创建线程对象，通过线程对象开启我们的线程，代理
        new Thread(testThread2).start();
        for (int i = 0; i &lt; 1000; i++) {
            System.out.println(&quot;我在学多线程---&quot; + i);
        }
    }
}
</code></pre>
<ul>
<li>实现callable（）接口</li>
</ul>
<h1 id="静态代理模式">静态代理模式</h1>
<ul>
<li>真实对象和代理对象都要实现同一个接口</li>
<li>代理对象要代理真实角色</li>
<li>好处
<ol>
<li>代理对象可以做很多真实对象做不了的事</li>
<li>真实对象专注做自己事</li>
</ol>
</li>
</ul>
<h1 id="lambda表达式">Lambda表达式</h1>
<ul>
<li>函数式接口
<ol>
<li>任何接口，如果只包含唯一一个抽象方法，那么他就是函数式接口</li>
<li>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象</li>
</ol>
</li>
<li>Runnable接口就是一个函数式接口</li>
<li>Lambda表达式实现</li>
</ul>
<pre><code class="language-java">public class LambdaTest {

    public static void main(String[] args) {
        //实现Lambda表达式
        ILove i = (x) -&gt; {
            System.out.println(&quot;I love you!&quot; + x);
        };
        i.print(20);
    }
}

//定义一个函数式接口
interface ILove {
    void print(int x);
}
</code></pre>
<h1 id="线程状态">线程状态</h1>
<figure data-type="image" tabindex="1"><img src="https://1489368019.github.io/post-images/1616295260818.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[写法]]></title>
        <id>https://1489368019.github.io/post/xie-fa/</id>
        <link href="https://1489368019.github.io/post/xie-fa/">
        </link>
        <updated>2021-03-18T11:17:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="学习javacsript">学习javacsript</h1>
<ul>
<li>学习java</li>
<li>学习数据库<br>
1 dawd</li>
</ul>
<ol>
<li>学习java</li>
<li>学习数据库</li>
</ol>
<blockquote>
<p>这是引用</p>
<blockquote>
<p>这是引用</p>
</blockquote>
</blockquote>
<pre><code class="language-javascript">  在此输入代码
</code></pre>
<p>这是一个链接<a href="https://null-go.github.io/">我的主页</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring概述]]></title>
        <id>https://1489368019.github.io/post/spring-gai-shu/</id>
        <link href="https://1489368019.github.io/post/spring-gai-shu/">
        </link>
        <updated>2021-03-18T11:13:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<ul>
<li>创始人Rod Johnson</li>
<li>Spring是轻量级、开源的JavaEE框架</li>
<li>可以解决企业应用开发的复杂性</li>
<li>核心部分：IOC 和 AOP
<ol>
<li>IOC：控制反转，把面向对象过程交给Spring管理</li>
<li>AOP：面向切面，不修改源代码进行功能增强</li>
</ol>
</li>
</ul>
<h1 id="特点">特点</h1>
<ul>
<li>方便解耦，简化开发</li>
<li>AOP编程支持</li>
<li>方便程序测试</li>
<li>方便集成各种优秀框架</li>
<li>方便进行事务操作</li>
<li>降低API开发难度</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java异常处理]]></title>
        <id>https://1489368019.github.io/post/java-yi-chang-chu-li/</id>
        <link href="https://1489368019.github.io/post/java-yi-chang-chu-li/">
        </link>
        <updated>2021-03-15T11:50:09.000Z</updated>
        <content type="html"><![CDATA[<p>1、异常的根类是Throwable，免检异常反应程序设计上的不可恢复的逻辑错误，包括Error、RuntimeException。必检异常强制检查并通过try-catch块处理或在方法头声明。<br>
2、如果方法没有在父类声明异常，就不能在子类中声明异常。<br>
3、</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java抽象类和接口]]></title>
        <id>https://1489368019.github.io/post/java-chou-xiang-lei-he-jie-kou/</id>
        <link href="https://1489368019.github.io/post/java-chou-xiang-lei-he-jie-kou/">
        </link>
        <updated>2021-03-14T11:36:51.000Z</updated>
        <content type="html"><![CDATA[<p>1、一个包含抽象方法的类必须被声明为抽象类。修饰符 abstr<br>
2、抽象类不能使用new创建实例，它的实现由子类提供。<br>
3、抽象类的构造方法定义为protect，因为它只被子类使用。<br>
4、子类实现抽象类中的方法，快捷键alt+Enter。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java多态]]></title>
        <id>https://1489368019.github.io/post/java-duo-tai/</id>
        <link href="https://1489368019.github.io/post/java-duo-tai/">
        </link>
        <updated>2021-03-13T06:33:56.000Z</updated>
        <content type="html"><![CDATA[<p>1、多态指使用父类对象的地方都可以使用子类的对象。<br>
2、把父类实例转换为子类变量时，必须使用转换记号（子类名）进行显示转换。<br>
3、对象调用成员变量由实际类型决定。<br>
4、protect修饰符可以被被不同包的子类访问。<br>
5、用final修饰符修饰类，是不能被继承的，修饰方法，不能被重写。<br>
6、编译看父类，运行看子类。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java继承]]></title>
        <id>https://1489368019.github.io/post/java-ji-cheng/</id>
        <link href="https://1489368019.github.io/post/java-ji-cheng/">
        </link>
        <updated>2021-03-12T02:58:22.000Z</updated>
        <content type="html"><![CDATA[<p>1、父类的private修饰的数据与和方法不被子类继承，构造方法也不被子类继承。<br>
2、子类不是父类的一个子集，子类通常比父类包含更多的信息和方法。<br>
3、父类和子类应该满足“是一种”关系（is-a），例：圆形是一种几何图形。但不是所有的“是一种”关系（is-a）都该用继承来建模，例：正方形是一种矩形。<br>
4、子类只允许有一个父类。<br>
5、子类的构造函数会默认将super（）作为第一条语句。<br>
6、如果父类只有有参函数，子类的构造函数要传入父类的参数。super（参数）<br>
7、私有方法和静态方法不能被覆盖，即方法重写。<br>
8、方法重写具有相同的签名（方法名和参数列表）和返回值类型。<br>
9、可以用@Override来标记方法重写。<br>
10、方法重载可以重载同一个类中的方法，也可以重载继承父类的方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://1489368019.github.io/post/hello-gridea/</id>
        <link href="https://1489368019.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>